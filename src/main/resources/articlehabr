Метод Thread.sleep()

Thread.sleep() — статический метод класса Thread, который приостанавливает выполнение потока,
в котором он был вызван. Во время выполнения метода sleep() система перестает выделять потоку
процессорное время, распределяя его между другими потоками. Метод sleep() может выполняться
либо заданное кол-во времени (миллисекунды или наносекунды) либо до тех пор пока он не будет
остановлен прерыванием (в этом случае он сгенерирует исключение InterruptedException).

Thread.sleep(1500); 		//Ждет полторы секунды
Thread.sleep(2000, 100);  	//Ждет 2 секунды и 100 наносекунд


Несмотря на то, что метод sleep() может принимать в качестве времени ожидания наносекунды, не
стоит принимать это всерьез. Во многих системах время ожидания все равно округляется до
миллисекунд а то и до их десятков.

Метод yield()

Статический метод Thread.yield() заставляет процессор переключиться на обработку других потоков
системы. Метод может быть полезным, например, когда поток ожидает наступления какого-либо
события и необходимо чтобы проверка его наступления происходила как можно чаще. В этом случае
можно поместить проверку события и метод Thread.yield() в цикл:

//Ожидание поступления сообщения
while(!msgQueue.hasMessages())		//Пока в очереди нет сообщений
{
	Thread.yield();		//Передать управление другим потокам
}


Метод join()

В Java предусмотрен механизм, позволяющий одному потоку ждать завершения выполнения другого.
Для этого используется метод join(). Например, чтобы главный поток подождал завершения побочного
потока myThready, необходимо выполнить инструкцию myThready.join() в главном потоке. Как только
поток myThready завершится, метод join() вернет управление, и главный поток сможет продолжить выполнение.

Метод join() имеет перегруженную версию, которая получает в качестве параметра время ожидания. В
этом случае join() возвращает управление либо когда завершится ожидаемый поток, либо когда закончится
время ожидания. Подобно методу Thread.sleep() метод join может ждать в течение миллисекунд и наносекунд
– аргументы те же.

С помощью задания времени ожидания потока можно, например, выполнять обновление анимированной картинки
пока главный (или любой другой) поток ждёт завершения побочного потока, выполняющего ресурсоёмкие операции:

Thinker brain = new Thinker(); 	//Thinker - потомок класса Thread.
brain.start();		//Начать "обдумывание".

do
{
	mThinkIndicator.refresh();		//mThinkIndicator - анимированная картинка.

	try{
		brain.join(250);				//Подождать окончания мысли четверть секунды.
	}catch(InterruptedException e){}
}
while(brain.isAlive());	//Пока brain думает...

//brain закончил думать (звучат овации).

Приоритеты потоков

Каждый поток в системе имеет свой приоритет. Приоритет – это некоторое число в объекте потока, более высокое значение которого означает больший приоритет. Система в первую очередь выполняет потоки с большим приоритетом, а потоки с меньшим приоритетом получают процессорное время только тогда, когда их более привилегированные собратья простаивают.

Работать с приоритетами потока можно с помощью двух функций:

void setPriority(int priority) – устанавливает приоритет потока.
Возможные значения priority — MIN_PRIORITY, NORM_PRIORITY и MAX_PRIORITY.

int getPriority() – получает приоритет потока.

Некоторые полезные методы класса Thread

Это практически всё. Напоследок приведу несколько полезных методов работы с потоками.

boolean isAlive() — возвращает true если myThready() выполняется и false если поток еще не был запущен или был завершен.

setName(String threadName) – Задает имя потока.
String getName() – Получает имя потока.
Имя потока – ассоциированная с ним строка, которая в некоторых случаях помогает понять, какой поток выполняет некоторое действие. Иногда это бывает полезным.

static Thread Thread.currentThread() — статический метод, возвращающий объект потока, в котором он был вызван.

long getId()– возвращает идентификатор потока. Идентификатор – уникальное число, присвоенное потоку.

Заключение

Отмечу, что в статье рассказано далеко не про все нюансы многопоточного программирования. И коду, приведенному в примерах, для полной корректности не хватает некоторых нюансов. В частности, в примерах не используется синхронизация. Синхронизация потоков — тема, не изучив которую, программировать правильные многопоточные приложения не получится. Почитать о ней вы можете, например, в книге «Java Concurrency in Practice» или здесь (всё на английском).

В статье были рассмотрены основные средства работы с потоками в Java. Если эта статья окажется полезной, то в следующей я расскажу о проблемах совместного доступа потоков к ресурсам и о методах их решения.
